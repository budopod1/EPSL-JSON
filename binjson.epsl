$import json;
$import conversion;

BinParsingState {
    W:i,
    [Str]:strs
}

W#take_VW_uint[Str:data][BinParsingState:state] {
    W:result = 0;
    W:shift = 0;
    while (true) {
        if ([data].len == state.i) {
            abort "Invalid BinJSON VW int";
        };
        Byte:curByte = data[state.i++];
        result += [[(W)curByte] & [127]] << [shift];
        shift += 7;
        if ([curByte] & [128] == 0) {
            return result;
        };
    };
}

Str#take_Str[Str:data][BinParsingState:state] {
    W:idx = take_VW_uint[data][state];
    if (idx >= [state.strs].len) {
        abort "Invalid BinJSON string index";
    };
    return state.strs[idx];
}

Str#take_bytes[Str:data][BinParsingState:state][W:count] {
    W:start = state.i;
    state.i += count;
    if (state.i > [data].len) {
        abort "Invalid BinJSON";
    };
    return [data].slice[start][state.i];
}

Byte#take_byte[Str:data][BinParsingState:state] {
    if ([data].len == state.i) {
        abort "Invalid BinJSON";
    };
    return data[state.i++];
}

JSONBool#parse_BinJSONBool[Str:data][BinParsingState:state] {
    return JSONBool [/*span:*/null, (Bool)take_byte[data][state]];
}

JSONDouble#parse_BinJSONDouble[Str:data][BinParsingState:state] {
    Q:val = unpack_Q64[data][state.i];
    state.i += 8;
    return JSONDouble [/*span:*/null, val];
}

JSONInt#parse_BinJSONInt[Str:data][BinParsingState:state] {
    return JSONInt [/*span:*/null, (Z)take_VW_uint[data][state]];
}

JSONList#parse_BinJSONList[Str:data][BinParsingState:state] {
    W:len = take_VW_uint[data][state];
    [:JSON]:items = [:JSON] [];
    if (len > 0) {
        Byte:sub_id = take_byte[data][state];
        for (W:i to len) {
            [items].append[parse_BinJSON_val[sub_id][data][state]];
        };
    };
    return JSONList [/*span:*/null, items];
}

JSONList#parse_BinJSONList_multityped[Str:data][BinParsingState:state] {
    W:len = take_VW_uint[data][state];
    [:JSON]:items = [:JSON] [];
    if (len > 0) {
        for (W:i to len) {
            Byte:sub_id = take_byte[data][state];
            [items].append[parse_BinJSON_val[sub_id][data][state]];
        };
    };
    return JSONList [/*span:*/null, items];
}

JSONObj#parse_BinJSONObj[Str:data][BinParsingState:state] {
    W:len = take_VW_uint[data][state];
    [Str]:keys = [Str] [];
    [:JSON]:values = [:JSON] [];
    for (W:i to len) {
        [keys].append[take_Str[data][state]];
        Byte:val_id = take_byte[data][state];
        [values].append[parse_BinJSON_val[val_id][data][state]];
    };
    return JSONObj [/*span:*/null, keys, values];
}

JSONStr#parse_BinJSONStr[Str:data][BinParsingState:state] {
    return JSONStr [/*span:*/null, take_Str[data][state]];
}

:JSON#parse_BinJSON_val[Byte:id][Str:data][BinParsingState:state] {
    switch (id)
    (1) {
        return parse_BinJSONBool[data][state];
    }
    (2) {
        return parse_BinJSONDouble[data][state];
    }
    (3) {
        return parse_BinJSONInt[data][state];
    }
    (4) {
        return parse_BinJSONList[data][state];
    }
    (5) {
        return JSONNull [/*span:*/null];
    }
    (6) {
        return parse_BinJSONObj[data][state];
    }
    (7) {
        return parse_BinJSONStr[data][state];
    }
    (8) {
        return parse_BinJSONList_multityped[data][state];
    }
    {
        abort "Invalid BinJSON ID";
    };
}

#write_VW_uint[W:val] to: [Str:target] {
    while (true) {
        Byte:b = (Byte)([127] & [val]);
        val = [val] >> [7];
        if (val) {
            b += (Byte)128;
        };
        [target].append[b];
        if (!val) {
            break;
        };
    };
}

Bool#[JSONList:list].has_homogeneous_ids {
    if ([list.items].len <= 1) {
        return true;
    };
    W:first_id = get_BinJSON_id[list.items[0]];
    for (:JSON:item in list.items from 1) {
        if (get_BinJSON_id[item] != first_id) {
            return false;
        };
    };
    return true;
}

Byte#get_BinJSON_id[:JSON:json] {
    given (json as JSONBool:bool) {
        return '\x01';
    } given (json as JSONDouble:double) {
        return '\x02';
    } given (json as JSONInt:int) {
        return '\x03';
    } given (json as JSONList:list) {
        if ([list].has_homogeneous_ids) {
            return '\x04';
        } else {
            return '\x08';
        };
    } given (json as JSONNull:null_) {
        return '\x05';
    } given (json as JSONObj:obj) {
        return '\x06';
    } given (json as JSONStr:str) {
        return '\x07';
    } else {
        abort "Invalid JSON";
    };
}

#write_BinJSON_str[Str:str] to: [Str:target] str_table: [[Str]:str_table] {
    for (L:i enumerating str_table) {
        if ([str] equals [str_table[i]]) {
            write_VW_uint[i] to: [target];
            return;
        };
    };
    write_VW_uint[[str_table].len] to: [target];
    [str_table].append[str];
}

#write_BinJSON[:JSON:json] to: [Str:target] str_table: [[Str]:str_table] {
    given (json as JSONBool:bool) {
        [target].append[(Byte)bool.val];
    } given (json as JSONDouble:double) {
        [target].extend[[double.val].pack];
    } given (json as JSONInt:int) {
        write_VW_uint[(W)int.val] to: [target];
    } given (json as JSONList:list) {
        if ([list.items].len == 0) {
            [target].append['\0'];
            return;
        };
        write_VW_uint[[list.items].len] to: [target];
        if ([list].has_homogeneous_ids) {
            [target].append[get_BinJSON_id[list.items[0]]];
            for (:JSON:item in list.items) {
                write_BinJSON[item] to: [target] str_table: [str_table];
            };
        } else {
            for (:JSON:item in list.items) {
                [target].append[get_BinJSON_id[item]];
                write_BinJSON[item] to: [target] str_table: [str_table];
            };
        };
    } given (json as JSONNull:null_) {
        // this intentionally does nothing
    } given (json as JSONObj:obj) {
        write_VW_uint[[obj.keys].len] to: [target];
        for (L:i enumerating obj.keys) {
            write_BinJSON_str[obj.keys[i]] to: [target] str_table: [str_table];
            :JSON:value = obj.values[i];
            [target].append[get_BinJSON_id[value]];
            write_BinJSON[value] to: [target] str_table: [str_table];
        };
    } given (json as JSONStr:str) {
        write_BinJSON_str[str.val] to: [target] str_table: [str_table];
    } else {
        abort "Invalid JSON";
    };
}
